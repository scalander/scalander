import api_app.models as models
from emailing.sendemail import availabilityEmail


from scheduling.scheduling import schedule, Block
from dataclasses import dataclass, field
from datetime import datetime, date

from typing import List

# timezone handler
from django.utils import timezone

@dataclass
class User:
    name: str # user's name 
    email: str # the user's email
    #### FAKEVALUES: only used during READ operations ####
    subscriptions: List[str] = field(default_factory=list) # a list of string UUIDs for subscriptions of the user

@dataclass
class Commitment:
    start: datetime # start of commitment block
    end: datetime # end of commitment block
    is_absolute: bool # whether the commitment is absolute
 
@dataclass
class Meeting:
    name: str # meeting name
    start: date # meeting start RANGE --- note this is not the start date
                # but the start of SCHEDULING range
    end: date   # see above, but end
    lock_in_date: date # no changes after this date
    length: int # length in minutes
    #### FAKEVALUES: only used during READ operations ####
    proposals: List[str] = field(default_factory=list) # a list of string UUIDs for proposals the meeting contains
    subscriptions: List[str] = field(default_factory=list) # a list of string UUIDs for the tickets people bound to the meeting
    # these values aren't part of the model class, but is a part of the dataclass      #
    # this is because, when someone gets the meeting, the *usually* want the proposals #
    # and subs together with it.                                                       #


@dataclass
class MeetingTimeProposal:
    meeting: str # UUID of meeting
    start: datetime # proposed start
    end: datetime # proposed end
    committed_attendences: List[str] # UIDs of tickets that are commited
    unavailable_attendences: List[str] # UIDs of tickets that are not commited
    optimality: int # a ranking generated by the API

# the following class is known as a UserMeetingSubscription
# in the internal schema; but publically called "ticket" or
# "attendance"
@dataclass
class UserAttendance: 
    user: str # UUID of the user attending
    meeting: str # UUID of the meeting they're attending
    is_critical: bool # whether or not they have to be there TODO
    weight: int # the weight of the attendee (higher more important)

######################################################################

#############
# /api/user #
#############

# C
def create_user(obj):
    model = models.User.objects.create(name=obj.name, email=obj.email)
    return model.id

# R
def get_user(id):
    user = models.User.objects.get(id=id)
    meeting_subscription_ids = [sub.id for sub in models.UserMeetingSubscription.objects.filter(user_id=id).all()]
    return User(user.name, user.email, meeting_subscription_ids)

def get_user_by_subscription(id):
    attendence = models.UserMeetingSubscription.objects.get(id=id)
    return get_user(attendence.user.id)

def get_user_by_commitment(id):
    attendence = models.MeetingProposalAttendance.objects.get(id=id)
    return get_user(attendence.user.id)

def get_uid_by_subscription(id):
    attendence = models.UserMeetingSubscription.objects.get(id=id)
    return attendence.user.id

# U
def update_user(id, obj):
    user = models.User.objects.get(id=id)
    user.name = obj.name
    user.email = obj.email
    user.save()

# D
def delete_user(id):
    user_model = models.User.objects.get(id=id)
    user_model.delete()

###################
# /api/commitment #
###################

# C
def create_commitment(obj):
    model = models.Commitment.objects.create(**(obj.__dict__))
    return model.id

# R
def get_commitment(id):
    commitment = models.Commitment.objects.get(id=id)
    return Commitment(start=commitment.start,
                      end=commitment.end,
                      is_absolute=commitment.is_absolute)
def get_commitments_by_user(uid):
    commitments = models.Commitment.objects.filter(user_id=uid)
    return [Commitment(start=commitment.start,
                       end=commitment.end,
                       is_absolute=commitment.is_absolute)
            for commitment in commitments]

# U
def update_commitment(id, obj):
    commitment = models.Commitment.objects.get(id=id)
    commitment.start, commitment.end, commitment.is_absolute = obj.start, obj.end, obj.is_absolute
    commitment.save()

# D
def delete_commitment(id):
    commitment = models.Commitment.objects.get(id=id)
    commitment.delete()

################
# /api/meeting #
################

# C
def create_meeting(obj):
    model = models.Meeting.objects.create(name=obj.name,
                                          start=obj.start,
                                          end=obj.end,
                                          length=obj.length,
                                          lock_in_date=obj.lock_in_date)

    # sets the values for proposals
    for proposal in obj.proposals:
        proposal_model = models.MeetingTimeProposal.objects.get(id=proposal)
        proposal_model.meeting_id = model.id
        proposal_model.save()

    for subscription in obj.subscriptions:
        subscription_model = models.UserMeetingSubscription.objects.get(id=subscription)
        subscription_model.meeting_id = model.id
        subscription_model.save()

    return model.id

# R
def get_meeting(id):
    meeting = models.Meeting.objects.get(id=id)

    # get also proposal and sub IDs
    # note that we order proposals by highest optimality first
    subscription_ids = [i.id for i in models.UserMeetingSubscription.objects.filter(meeting=id).all()]
    proposal_ids = [i.id for i in models.MeetingTimeProposal.objects.filter(meeting=id).order_by("-optimality")]

    
    return Meeting(meeting.name, meeting.start, meeting.end,
                   meeting.lock_in_date, meeting.length,
                   proposal_ids, subscription_ids)

# U
def update_meeting(id, obj):
    meeting = models.Meeting.objects.get(id=id)
    meeting.name, meeting.start, meeting.end, meeting.length, meeting.lock_in_date = obj.name, obj.start, obj.end, obj.length, obj.lock_in_date
    meeting.save()

# D
def delete_meeting(id):
    meeting = models.Meeting.objects.get(id=id)
    meeting.delete()

##################
# /api/proposal ## # CRD, no U
##################

# C
def create_proposal(obj):
    model = models.MeetingTimeProposal.objects.create(meeting_id=obj.meeting,
                                                      start=obj.start,
                                                      end=obj.end,
                                                      optimality=obj.optimality)
    for committed in obj.committed_attendences:
        committed_model = models.MeetingProposalAttendance.objects.create(proposal_id=model.id,
                                                                          user_subscription_id=committed,
                                                                          is_committed=True)
    for unavailable in obj.unavailable_attendences:
        unavailable_model = models.MeetingProposalAttendance.objects.create(proposal_id=model.id,
                                                                            user_subscription_id=unavailable,
                                                                            is_committed=False)
    return model.id

# R
def get_proposal(id):
    proposal = models.MeetingTimeProposal.objects.get(id=id)
    attendances = models.MeetingProposalAttendance.objects.filter(proposal_id=id).all()

    committed_subscriptions = [i.user_subscription for i in filter(lambda i:i.is_committed==True, attendances)]
    unavailable_subscriptions = [i.user_subscription for i in filter(lambda i:i.is_committed==False, attendances)]

    return MeetingTimeProposal(proposal.meeting.id, proposal.start, proposal.end, committed_subscriptions, unavailable_subscriptions, proposal.optimality)

# D
def delete_proposal(id):
    proposal = models.MeetingTimeProposal.objects.get(id=id)
    proposal.delete()

####################
# /api/attendance ##
####################

def create_attendance(obj):
    model = models.UserMeetingSubscription.objects.create(user_id=obj.user,
                                                          meeting_id=obj.meeting,
                                                          is_critical=obj.is_critical,
                                                          weight=obj.weight)
    # if a user wants to attend, they get te get an email
    # about getting their time!
    availabilityEmail(obj.meeting, obj.user)
    return model.id

def get_attendance(id):
    subscription = models.UserMeetingSubscription.objects.get(id=id)
    return UserAttendance(user=subscription.user.id,
                          meeting=subscription.meeting.id,
                          is_critical=subscription.is_critical,
                          weight=subscription.weight)

def update_attendance(id, obj):
    subscription = models.UserMeetingSubscription.objects.get(id=id)
    subscription.meeting_id, subscription.is_critical, subscription.weight = obj.meeting, obj.is_critical, obj.weight
    subscription.save()

def delete_attendance(id):
    delete_subscription(id)

##########################
# /api/many-commitments ##
##########################

def create_many_commitments(id, commitments):
    # deletes previous commitments
    models.Commitment.objects.filter(user_id=id).delete()
    # seed new commitments
    new_commits = [models.Commitment(start=c.start, end=c.end, is_absolute=True, user_id=id) for c in commitments]
    # bulk create it
    models.Commitment.objects.bulk_create(new_commits)
    # return IDs
    return [i.id for i in new_commits]

##########################

# and now... utiltiies!

def check_commitment(users, start, end):
    """Checks if any of a user's commitment includes a time range

    Arguments:
        users: [uidType] - user IDs of who to check
        start: datetime.DateTime - start of range
        end: datetime.DateTime - end of range

    Returns:
        list of uidtype, the IDs of users availaible
    """

    # get commitments
    res = models.Commitment.objects.filter(user_id__in=users, # users
                                           start__lte=start, # start time must fit
                                           end__gte=end) # end time ALSO must fit!

    # get the ID of the users available
    # use set() for duplicate filtering
    avail_ids = list(set([i.user.id for i in res]))

    # we hope to have some non-empty result, if user is available
    return avail_ids
    
def schedule_user(user):
    """Reschedules all of a user's meetings, if they are BEFOER the lock date

    Arguments:
         user: User - the user te reschedule
    """
    for m_id in user.subscriptions:
        sub = get_attendance(m_id)
        meeting = get_meeting(sub.meeting)
        results = schedule([Block(meeting.start, meeting.end)], meeting.length, meeting.subscriptions, 15, 5)
        # TODO: more accurate optimality calculation (i.e. reflect times, bounds, etc.)
        # create proposal dataclasses
        new_proposals = [MeetingTimeProposal(sub.meeting,
                                             result.start, result.end,
                                             result.can, result.cannot,
                                             result.total_weight) for result in results]
        # remove all old proposals for that meeting
        models.MeetingTimeProposal.objects.filter(meeting_id=sub.meeting).delete()
        
        # if we are BEFORE the lock date of the meeting
        # this is a handler which uses handler
        # if timezone.now() < meeting.lock_in_date:
        # submit new proposals for creation
        # TODO
        [create_proposal(i) for i in new_proposals]
        


        



